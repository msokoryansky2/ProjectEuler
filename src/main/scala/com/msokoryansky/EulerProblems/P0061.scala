package com.msokoryansky.EulerProblems

import com.msokoryansky.MathUtils.PolygonalNumber

/*


Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers
and are generated by the following formulae:
Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
Square 	  	P4,n=n2 	  	1, 4, 9, 16, 25, ...
Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
Hexagonal 	  	P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first two digits of the next number
    including the last number with the first).

Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),
    is represented by a different number in the set.

This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

 */

class P0061 extends EulerProblem {
  def run: String = {
    // Map from 3/4/5/6/7/8 to all polygonal numbers of that polygonalness
    val ps = (3 to 8).map(ness => (ness, PolygonalNumber(ness).numbersOfLength(4))).toMap
    // Map 3..8 to map from all possible two-digit prefixes to polygonal numbers of that polygonalness with that prefix
    val psStart = (3 to 8).map(ness =>
                    (ness, (10 to 99).map(start =>
                      (start, ps(ness).filter(p =>
                        p / 100 == start))).filterNot(_._2.isEmpty).toMap)).toMap
    // Map 3..8 to map from all possible two-digit suffixes to polygonal numbers of that polygonalness with that suffix
    val psEnd = (3 to 8).map(ness =>
                    (ness, (10 to 99).map(end =>
                      (end, ps(ness).filter(p =>
                        p % 100 == end))).filterNot(_._2.isEmpty).toMap)).toMap

    (for {
      nessA <- 3 to 8
      nessB <- 3 to 8 if nessB != nessA
      nessC <- 3 to 8 if nessC != nessA && nessC != nessB
      nessD <- 3 to 8 if nessD != nessA && nessD != nessB && nessD != nessC
      nessE <- 3 to 8 if nessE != nessA && nessE != nessB && nessE != nessC && nessE != nessD
      nessF <- 3 to 8 if nessF != nessA && nessF != nessB && nessF != nessC && nessF != nessD && nessF != nessE

      if psStart.contains(nessA) && psStart(nessA).nonEmpty
      prefA <- psStart(nessA).keys
      if psStart(nessA).contains(prefA) && psStart(nessA)(prefA).nonEmpty
      suffA <- psStart(nessA)(prefA).map(_ % 100)
      prefB = suffA.toInt
      if psStart.contains(nessB) && psStart(nessB).nonEmpty
      if psStart(nessB).contains(prefB) && psStart(nessB).contains(prefB)
      suffB <- psStart(nessB)(prefB).map(_ % 100)
      prefC = suffB.toInt
      if psStart.contains(nessC) && psStart(nessC).nonEmpty
      if psStart(nessC).contains(prefC) && psStart(nessC)(prefC).nonEmpty
      suffC <- psStart(nessC)(prefC).map(_ % 100)
      prefD = suffC.toInt
      if psStart.contains(nessD) && psStart(nessD).nonEmpty
      if psStart(nessD).contains(prefD) && psStart(nessD)(prefD).nonEmpty
      suffD <- psStart(nessD)(prefD).map(_ % 100)
      prefE = suffD.toInt
      if psStart.contains(nessE) && psStart(nessE).nonEmpty
      if psStart(nessE).contains(prefE) && psStart(nessE)(prefE).nonEmpty
      suffE <- psStart(nessE)(prefE).map(_ % 100)
      prefF = suffE.toInt
      if psStart.contains(nessF) && psStart(nessF).nonEmpty
      if psStart(nessF).contains(prefF) && psStart(nessF)(prefF).nonEmpty
      suffF <- psStart(nessF)(prefF).map(_ % 100)
      if prefA == suffF

      a = (prefA.toString + suffA.toString).toLong
      b = (prefB.toString + suffB.toString).toLong if b != a
      c = (prefC.toString + suffC.toString).toLong if c != a && c != b
      d = (prefD.toString + suffD.toString).toLong if d != a && d != b && d != c
      e = (prefE.toString + suffE.toString).toLong if e != a && e != b && e != c && e != d
      f = (prefF.toString + suffF.toString).toLong if f != a && c != b && f != c && f != d && f != e

      if (a > b && b > c && c > d && d > e && e > f) || (a < b && b < c && c < d && d < e && e < f)
    } yield (nessA -> a, nessB -> b, nessC -> c, nessD -> d, nessE -> e, nessF -> f)).toString
  }
}

object P0061 extends App {
  (new P0061).printAnswer()
}