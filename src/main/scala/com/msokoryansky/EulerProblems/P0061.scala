package com.msokoryansky.EulerProblems

import com.msokoryansky.MathUtils.PolygonalNumber

/*


Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers
and are generated by the following formulae:
Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
Square 	  	P4,n=n2 	  	1, 4, 9, 16, 25, ...
Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
Hexagonal 	  	P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first two digits of the next number
    including the last number with the first).

Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),
    is represented by a different number in the set.

This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

 */

class P0061 extends EulerProblem {
  def run: String = {
    // Map 3..8 to map from all possible two-digit prefixes to polygonal numbers of that polygonalness with that prefix
    val ps = (3 to 8).map(ness =>
                    (ness, (10 to 99).map(start =>
                      (start, PolygonalNumber(ness).numbersOfLength(4).filter(p =>
                        p / 100 == start))).filterNot(_._2.isEmpty).toMap)).toMap

    (for {
      nessA <- 3 to 3
      nessB <- 3 to 8 if nessB != nessA
      nessC <- 3 to 8 if nessC != nessA && nessC != nessB
      nessD <- 3 to 8 if nessD != nessA && nessD != nessB && nessD != nessC
      nessE <- 3 to 8 if nessE != nessA && nessE != nessB && nessE != nessC && nessE != nessD
      nessF <- 3 to 8 if nessF != nessA && nessF != nessB && nessF != nessC && nessF != nessD && nessF != nessE

      if ps.contains(nessA) && ps(nessA).nonEmpty
      prefA <- ps(nessA).keys
      if ps(nessA).contains(prefA) && ps(nessA)(prefA).nonEmpty
      suffA <- ps(nessA)(prefA).map(_ % 100)
      prefB = suffA.toInt
      if ps.contains(nessB) && ps(nessB).nonEmpty
      if ps(nessB).contains(prefB) && ps(nessB).contains(prefB)
      suffB <- ps(nessB)(prefB).map(_ % 100)
      prefC = suffB.toInt
      if ps.contains(nessC) && ps(nessC).nonEmpty
      if ps(nessC).contains(prefC) && ps(nessC)(prefC).nonEmpty
      suffC <- ps(nessC)(prefC).map(_ % 100)
      prefD = suffC.toInt
      if ps.contains(nessD) && ps(nessD).nonEmpty
      if ps(nessD).contains(prefD) && ps(nessD)(prefD).nonEmpty
      suffD <- ps(nessD)(prefD).map(_ % 100)
      prefE = suffD.toInt
      if ps.contains(nessE) && ps(nessE).nonEmpty
      if ps(nessE).contains(prefE) && ps(nessE)(prefE).nonEmpty
      suffE <- ps(nessE)(prefE).map(_ % 100)
      prefF = suffE.toInt
      if ps.contains(nessF) && ps(nessF).nonEmpty
      if ps(nessF).contains(prefF) && ps(nessF)(prefF).nonEmpty
      suffF <- ps(nessF)(prefF).map(_ % 100)
      if prefA == suffF

      a = (prefA.toString + suffA.toString).toLong
      b = (prefB.toString + suffB.toString).toLong if b != a
      c = (prefC.toString + suffC.toString).toLong if c != a && c != b
      d = (prefD.toString + suffD.toString).toLong if d != a && d != b && d != c
      e = (prefE.toString + suffE.toString).toLong if e != a && e != b && e != c && e != d
      f = (prefF.toString + suffF.toString).toLong if f != a && c != b && f != c && f != d && f != e

    } yield a + b + c + d + e + f).head.toString
  }
}

object P0061 extends App {
  (new P0061).printAnswer()
}